# audiofilters.py

import numpy as np
import matplotlib.pyplot as plt


def parallel(element1, element2):
    return element1 * element2 / (element1 + element2)


class Resistor:
    def __init__(self, r, f=np.arange(20, 20001)):
        self.r = r
        self.x = np.zeros(len(f))
        self.z = self.r + self.x


class Inductor:
    def __init__(self, inductance, dcr=0.0, f=np.arange(20, 20001)):
        self.inductance = inductance
        self.r = np.full(len(f), dcr)
        self.x = 2j * np.pi * f * self.inductance
        self.z = self.r + self.x


class Capacitor:
    def __init__(self, capacitance, dcr=0.0, f=np.arange(20, 20001)):
        self.capacitance = capacitance
        self.r = np.full(len(f), dcr)
        self.x = 1 / (2j * np.pi * f * self.capacitance)
        self.z = self.r + self.x


class LC_LPFilter:
    def __init__(self, l, c, dz):
        # self.fc = fc
        # self.order = order
        # self.q = q
        self.ho = c.z / (l.z + c.z)

        # A terminated response is required to correctly simulate filter behavior.
        # Probably best to implement this later.
        # A terminated transfer function is simply Zl/(Zl + Zo) * ho
        self.h = self.ho * dz / (dz + (l.z * self.ho))
        self.zi = l.z + (c.z * dz) / (c.z + dz)


"""INSPECT THIS, IT IS CLOSE BUT NOT PERFECT"""
class Tank_LPFilter:
    def __init__(self, c1, l1, c2, dz):
        self.ho = c2.z / (((l1.z * c1.z) / (l1.z + c1.z)) + c2.z)
        self.zo = self.ho * ((l1.z * c1.z) / (l1.z + c1.z))
        # this is probably the issue, read more about filter transfer functions.
        self.h = self.ho * dz / (dz + self.zo)
        self.zi = (c1.z * l1.z) / (c1.z + l1.z) + (c2.z * dz) / (c2.z + dz)


"""INSPECT THIS, IT IS CLOSE BUT NOT PERFECT"""
class Padded_HPFilter:
    def __init__(self, r1, c1, l1, dz):
        self.ho = l1.z / (r1.z + c1.z + l1.z)
        self.zo = self.ho * (r1.z + c1.z)
        # this is probably the issue, read more about filter transfer functions.
        self.h = self.ho * dz / (dz + self.zo)
        self.zi = (r1.z + c1.z) + dz * l1.z / (dz + l1.z)


class Driver:
    def __init__(self, frdFile=None, zmaFile=None):
        if frdFile is None:
            self.freq = []
            self.amp = []
            self.phase = []
        else:
            self.freq, self.amp, self.phase = self.read_frd_file(frdFile)
            self.frd = 10 ** (self.amp / 10) * np.exp(1j * np.pi / 180 * self.phase)
        if zmaFile is None:
            imp = []
            angle = []
        else:
            imp, angle = self.read_zma_file(zmaFile)
            self.z = imp * np.exp(1j * np.pi / 180 * angle)

    def apply_filter(self, filterH):
        self.out = self.frd * filterH.h
        self.fAmp = 10 * np.log10(np.abs(self.out))
        self.fPhase = np.mod(np.angle(self.out, deg=True) + 180, 360) - 180
        self.z = filterH.zi

    @staticmethod
    def read_frd_file(file):
        with open(file, 'r') as f:
            raw = f.read()
            if '" file generated by Xsim ' in raw:
                raw = raw[89:].split()
            else:
                raw = raw.split()
            fl = np.array([float(r) for r in raw])
            freq = fl[0::3]
            amp = fl[1::3]
            phase = fl[2::3]
            return freq, amp, phase

    @staticmethod
    def read_zma_file(file):
        with open(file, 'r') as f:
            raw = f.read()
            if '" file generated by Xsim ' in raw:
                raw = raw[96:].split()
            else:
                raw = raw.split()
            fl = np.array([float(r) for r in raw])
            # freq = fl[0::3]
            impedance = fl[1::3]
            angle = fl[2::3]
            return impedance, angle

    def plot(self):
        fig = plt.figure(1)

        ax1 = fig.add_subplot(211)
        plt.xscale('log')
        ax1.plot(self.freq, self.phase, c='r')
        ax1.set_ylabel('Phase (deg)', color='r')
        ax1.set_xlim(20, 20000)
        ax1.set_ylim(-190, 190)

        ax2 = ax1.twinx()
        plt.xscale('log')
        ax2.plot(self.freq, self.amp, c='b')
        ax2.set_title('Frequency Response')
        ax2.set_ylabel('dBSPL', color='b')
        ax2.set_xlim(20, 20000)
        ax2.set_ylim(60, 120)

        ax3 = fig.add_subplot(212)
        plt.xscale('log')
        ax3.plot(self.freq, self.fAmp, c='b')
        ax3.set_ylabel('Filtered dBSPL', color='b')
        ax3.set_xlim(20, 20000)
        ax3.set_ylim(60, 120)

        ax4 = ax3.twinx()
        plt.xscale('log')
        ax4.plot(self.freq, self.fPhase, c='r')
        ax4.set_ylabel('Filtered Phase (deg)', color='r')
        ax4.set_xlabel('Frequency (Hz)')
        ax4.set_xlim(20, 20000)
        ax4.set_ylim(-190, 190)

        plt.tight_layout()
        plt.show()

    def compare(self, frdFile, zmaFile):
        cFreq, cAmp, cPhase = self.read_frd_file(frdFile)
        cImp, cAngle = self.read_zma_file(zmaFile)
        fig = plt.figure(1, figsize=(15, 9))

        ax1 = fig.add_subplot(211)
        ax1.set_title('Frequency Response')
        ax1.set_ylabel('Amplitude', color='r')
        ax1.set_ylim(0, 100)
        line1, = ax1.plot(self.freq, self.fAmp, c='r')
        line2, = ax1.plot(cFreq, cAmp, color='orange')
        ax1.legend((line1, line2), ('Calc dBSPL', 'Xsim dBSPL'), loc='upper right')
        plt.xscale('log')

        ax2 = ax1.twinx()
        ax2.set_ylabel('Phase', color='b')
        ax2.set_ylim((-200, 200))
        line3, = ax2.plot(self.freq, self.fPhase, c='b')
        line4, = ax2.plot(cFreq, cPhase, c='cyan')
        ax2.legend((line3, line4), ('Calc phase', 'Xsim phase'), loc='upper left')

        ax3 = fig.add_subplot(212)
        ax3.set_title('Impedance')
        ax3.set_ylabel('Magnitude', color='r')
        # ax3.set_ylim((0, 20))
        line5, = ax3.plot(self.freq, np.abs(self.z), c='r')
        line6, = ax3.plot(cFreq, cImp, c='b')
        ax3.legend((line5, line6), ('Calc resistance', 'Xsim resistance'))
        plt.xscale('log')

        plt.tight_layout()
        plt.show()


    @staticmethod
    def read_frd_file(file):
        with open(file, 'r') as f:
            raw = f.read()
            if '" file generated by Xsim ' in raw:
                raw = raw[89:].split()
            else:
                raw = raw.split()
            fl = np.array([float(r) for r in raw])
            freq = fl[0::3]
            amp = fl[1::3]
            phase = fl[2::3]
            return freq, amp, phase

    @staticmethod
    def read_zma_file(file):
        with open(file, 'r') as f:
            raw = f.read()
            if '" file generated by Xsim ' in raw:
                raw = raw[96:].split()
            else:
                raw = raw.split()
            fl = np.array([float(r) for r in raw])
            # freq = fl[0::3]
            impedance = fl[1::3]
            angle = fl[2::3]
            return impedance, angle

def main():
    wDir = 'C:\\Users\\Morgan\\Documents\\GitHub\\Speaker Design\\Drivers\\Dayton-Audio-DA175-8\\'
    wooferFRD = wDir + 'FRD\\xsim_frd.frd'
    wooferZMA = wDir + 'ZMA\\xsim_zma.zma'
    wCompFRD = wDir + 'FRD\\tank.frd'
    wCompZMA = wDir + 'ZMA\\tank.zma'

    tDir = 'C:\\Users\\Morgan\\Documents\\GitHub\\Speaker Design\\Drivers\\Dayton-Audio-DC28F-8\\'
    tweeterFRD = tDir + 'FRD\\xsim_frd.frd'
    tweeterZMA = tDir + 'ZMA\\xsim_zma.zma'
    tCompFRD = tDir + 'FRD\\filtered.frd'
    tCompZMA = tDir + 'ZMA\\filtered.zma'

    daytonWoofer = Driver(wooferFRD, wooferZMA)
    c1 = Capacitor(0.56e-6, dcr=0.05, f=daytonWoofer.freq)
    c2 = Capacitor(6.8e-6, dcr=0.05, f=daytonWoofer.freq)
    l1 = Inductor(1.4e-3, dcr=0.350, f=daytonWoofer.freq)
    tfh = Tank_LPFilter(c1=c1, l1=l1, c2=c2, dz=daytonWoofer.z)

    daytonWoofer.apply_filter(tfh)
    # daytonWoofer.plot()

    daytonTweeter = Driver(tweeterFRD, tweeterZMA)
    r1 = Resistor(5.6, f=daytonTweeter.freq)
    c3 = Capacitor(8.2e-6, dcr=0.05, f=daytonTweeter.freq)
    l2 = Inductor(0.2e-3, dcr=0.3, f=daytonTweeter.freq)
    hfh = Padded_HPFilter(r1, c3, l2, dz=daytonTweeter.z)

    daytonTweeter.apply_filter(hfh)
    # daytonTweeter.plot()

    freq = daytonTweeter.freq

    """THIS IS THE CORRECT WAY TO DO IT
    Parallel filter responses are added together, series filter responses are multiplied together."""
    twoWayResponse = daytonTweeter.out + daytonWoofer.out
    twoWayAmp = 10 * np.log10(np.abs(twoWayResponse))
    twoWayPhase = np.angle(twoWayResponse, deg=True)
    twoWayImp = daytonTweeter.z * daytonWoofer.z / (daytonTweeter.z + daytonWoofer.z)

    combo = Driver()
    combo.freq = freq
    combo.fAmp = twoWayAmp
    combo.fPhase = twoWayPhase
    combo.z = twoWayImp
    sysFRD = 'C:\\Users\\Morgan\\Documents\\GitHub\\Speaker Design\\system.FRD'
    sysZMA = 'C:\\Users\\Morgan\\Documents\\GitHub\\Speaker Design\\system.ZMA'
    daytonWoofer.compare(wCompFRD, wCompZMA)
    daytonTweeter.compare(tCompFRD, tCompZMA)
    combo.compare(sysFRD, sysZMA)


if __name__ == '__main__':
    main()
